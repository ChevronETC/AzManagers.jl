<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AzManagers · AzManagers</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">AzManagers</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>AzManagers</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Scale-set-templates"><span>Scale-set templates</span></a></li><li class="toplevel"><a class="tocitem" href="#VM-images"><span>VM images</span></a></li><li class="toplevel"><a class="tocitem" href="#Azure-manifest"><span>Azure manifest</span></a></li><li class="toplevel"><a class="tocitem" href="#Logging"><span>Logging</span></a></li><li class="toplevel"><a class="tocitem" href="#Detached-service"><span>Detached service</span></a></li><li class="toplevel"><a class="tocitem" href="#A-note-about-MPI-(experimental)"><span>A note about MPI (experimental)</span></a></li><li class="toplevel"><a class="tocitem" href="#Custom-environments"><span>Custom environments</span></a></li></ul></li><li><a class="tocitem" href="examples/">Examples</a></li><li><a class="tocitem" href="reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>AzManagers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AzManagers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ChevronETC/AzManagers.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="AzManagers"><a class="docs-heading-anchor" href="#AzManagers">AzManagers</a><a id="AzManagers-1"></a><a class="docs-heading-anchor-permalink" href="#AzManagers" title="Permalink"></a></h1><p>AzManagers is a Julia resource/cluster manager for Azure scale-sets. In turn, An Azure scale-set is a collection of virtual machines (VMs).  To describe the scale-set, AzManagers uses a user-defined template.  For example, we can create a new julia cluster consisting of 5 VMs, and where the scale-set is described by the template <code>&quot;myscaleset&quot;</code> as follows,</p><pre><code class="language-julia">using AzManagers, Distributed
addprocs(&quot;myscaleset&quot;, 5)</code></pre><p>Note that <code>addprocs</code> will return as soon as the provisioning is initialized.  Subsequently, workers will add themselves to the Julia cluster as they become available.  This is similar to the &quot;elastic.jl&quot;  cluster manager in <a href="https://github.com/JuliaParallel/ClusterManagers.jl">ClusterManagers.jl</a>, and allows AzManagers to behave dynamically.  To wait for the cluster to be completely up use the <code>waitfor</code> argument. For example,</p><pre><code class="language-julia">using AzManagers, Distributed
addprocs(&quot;myscaleset&quot;, 5; waitfor=true)</code></pre><p>In this case <code>addprocs</code> will return only once the 5 workers have joined the cluster.</p><p>The scaleset template, `&quot;myscaleset&quot;&#39; describes the compute infrastructure.  Importantly, this includes the image that is attached to the VMs.  The user is responsible for creating this image, and ensuring that it contains both julia and the AzManagers package.  In the future, we will work to provide standard images.  Please see the section <a href="# VM images">VM images</a> for more information.</p><p>AzManagers does not provide scale-set templates since they will depend on your specific Azure setup.  However, we provide a means to create the templates.  Please see the section <a href="# Scale-set templates">Scale-set templates</a> for more information. </p><p>AzManagers requires a user provided Azure resource group and subscription, as well as information about the ssh user for the scale-set VMs.  AzManagers uses a manifest file to store this information. See the section <a href="# AzManagers manifest">AzManagers manifest</a> for more information.</p><p>The consequence of the above is that, at preset, we place the burden on the user to correctly, 1) create an image, 2) create templates, and 3) create a manifest file.</p><p>In addition to the julia cluster/scale-set functionality, AzManagers provides a method for running and monitoring arbitrary julia code on an Azure VM.  This is useful for long running processes in a way that is completely independent of your personal computer.  See the section <a href="# Detached service">Detached service</a> for more information.</p><h1 id="Scale-set-templates"><a class="docs-heading-anchor" href="#Scale-set-templates">Scale-set templates</a><a id="Scale-set-templates-1"></a><a class="docs-heading-anchor-permalink" href="#Scale-set-templates" title="Permalink"></a></h1><p>To create a scale-set template, use <code>AzManagers.build_sstemplate</code> and <code>AzManagers.save_template_scaleset</code> methods.  For example:</p><pre><code class="language-julia">using AzManagers
myscaleset = AzManagers.build_sstemplate(&quot;myvm&quot;,
    subscriptionid       = &quot;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&quot;,
    admin_username       = &quot;linuxuser&quot;,
    location             = &quot;southcentralus&quot;,
    resourcegroup        = &quot;my-resource-group&quot;,
    vnet                 = &quot;my-vnet&quot;,
    subnet               = &quot;my-vnets-subnet&quot;,
    imagegallery         = &quot;my-image-gallery&quot;,
    imagename            = &quot;my-image-name&quot;,
    skuname              = &quot;Standard_D2s_v3&quot;)
AzManagers.save_template_scaleset(&quot;myscaleset&quot;, myscaleset)</code></pre><p>The above code will save the template to the json file, <code>~/.azmanagers/templates_scaleset.json</code>. Subsequently, <code>addprocs(&quot;myscaleset&quot;, 5)</code> will query the json file for the VM template.  One can repeat this process, populating <code>~/.azmanagers/templates_scaleset.json</code> with a variety of templates for a variety of machine types.</p><h1 id="VM-images"><a class="docs-heading-anchor" href="#VM-images">VM images</a><a id="VM-images-1"></a><a class="docs-heading-anchor-permalink" href="#VM-images" title="Permalink"></a></h1><p>In the previous section, notice that <code>AzManagers.build_sstemplate</code> includes the arguments <code>imagename</code> and <code>imagegallery</code>.  This specifies the Azure image that will be attached to each VM in the scale-set.  In order to build an Azure image and place it in an image gallery,  we recommend using packer (https://www.packer.io/).  It is important that the image should contain the software that you want to run on the machines in the Julia cluster, and that should include both Julia and the AzManagers package.</p><h1 id="Azure-manifest"><a class="docs-heading-anchor" href="#Azure-manifest">Azure manifest</a><a id="Azure-manifest-1"></a><a class="docs-heading-anchor-permalink" href="#Azure-manifest" title="Permalink"></a></h1><p>The manifest is stored in <code>~/.azmanagers/manifest.json</code>, and contains information that is specific to your Azure setup.  We create the manifest using the <code>AzManagers.write_manifest</code> method.  For example,</p><pre><code class="language-julia">using AzManagers
AzManagers.write_manifest(;
    resourcegroup  = &quot;my-resource-group&quot;,
    subscriptionid = &quot;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&quot;,
    ssh_user = &quot;username&quot;)</code></pre><p>One can also specify the locations of the public and private ssh keys which AzManagers will use to establish ssh connections to the cluster machines.  This connection is used for the initial set-up of the cluster, and for sending log messages back to the master process.  By default, the private key is <code>~/.ssh/azmanagers_rsa</code> and the public key is <code>~/.ssh/azmanagers_rsa.pub</code>. Create the key-pair via the linux command,</p><pre><code class="language-none">ssh-keygen -f /home/cvx/.ssh/azmanagers_rsa -N &#39;&#39;</code></pre><h1 id="Logging"><a class="docs-heading-anchor" href="#Logging">Logging</a><a id="Logging-1"></a><a class="docs-heading-anchor-permalink" href="#Logging" title="Permalink"></a></h1><p>By default, logs in AzManagers behaves the same as Julia&#39;s <code>SSHManager</code>.  In particular, log messages generated by <code>@info</code> and-the-like are sent to the master process over ssh.  However, it is useful to note that a custom logger that sends worker messages to a cloud logger services such as azure log analytics might be useful.  At this time, AzManagers does not provide such a logger; but, if one had such a logger (e.g. MyAzureLogger), then one would do:</p><pre><code class="language-none">using AzManagers, Distributed
addprocs(&quot;myscaleset&quot;,5)
@everywhere using Logging, MyAzureLogger
@everywhere global_logger(MyAzureLogger())</code></pre><h1 id="Detached-service"><a class="docs-heading-anchor" href="#Detached-service">Detached service</a><a id="Detached-service-1"></a><a class="docs-heading-anchor-permalink" href="#Detached-service" title="Permalink"></a></h1><p>For long running processes it is convenient to use an Azure VM for the master process, and where that Azure VM is independent of your personal computer.  To accomplish this, AzManagers provides an <code>addproc</code> method that creates an azure VM (i.e. a detached VM), and also starts a very small web service to allow for the querying of the detached VM.  A convenience macro <code>@detachat</code> is provided for running code on the detached VM. In a way this is similar to an Azure function but without some of its limitation (e.g. time limits).  Here is an example:</p><pre><code class="language-julia">using AzManagers

myvm = addproc(&quot;myvm&quot;)
detached_job = @detachat myvm begin
    @info &quot;this is running on the detached vm&quot;
end

read(detached_job) # returns the job&#39;s stdout
read(detached_job; stdio=stderr) # returns the job&#39;s stderr
status(detached_job) # returns the status of the detached job
wait(detached_job) # blocks unitl the detached job is completed
rmproc(myvm)</code></pre><p>In the above example, <code>&quot;myvm&quot;</code> is a template similar to a scale-set template, and can be created in a similar way using the <code>AzManagers.build_vmtemplate</code> and <code>AzManagers.save_template_vm</code> methods. In addition, you will need to create a template for a network interface card (NIC) using the <code>AzManagers.build_nictemplate</code> and <code>AzManagers.save_template_nic</code> methods.</p><p>In a more involved example, one might want to serialize and send variables to the detached VM.  In the following example, we use the <code>variablebundle!</code> and <code>variablebundle</code> methods to accomplish this task.</p><pre><code class="language-julia">using AzManagers, AzSessions

variablebundle!(session = AzSession())

myvm = addproc(&quot;myvm&quot;)
detached_job = @detachat myvm begin
    using Distributed, AzManagers
    addprocs(&quot;myscaleset&quot;, 5; session=variablebundle(:session))
    for pid in workers()
        remotecall_fetch(println, &quot;hello from pid=$(myid())&quot;)
    end
    rmprocs(workers())
end
wait(detached_job)
rmproc(vm)</code></pre><h1 id="A-note-about-MPI-(experimental)"><a class="docs-heading-anchor" href="#A-note-about-MPI-(experimental)">A note about MPI (experimental)</a><a id="A-note-about-MPI-(experimental)-1"></a><a class="docs-heading-anchor-permalink" href="#A-note-about-MPI-(experimental)" title="Permalink"></a></h1><p>We have experimental support for inter-node MPI communication.  In other words, we allow for each Julia worker to have its own MPI communicator.  For example, this is useful for interacting with Devito.jl, and where there are performance benefits to parallel work within a many-core VM via a mix of MPI and OpenMP.</p><h1 id="Custom-environments"><a class="docs-heading-anchor" href="#Custom-environments">Custom environments</a><a id="Custom-environments-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-environments" title="Permalink"></a></h1><p>AzManagers can create an on-the-fly custom Julia software environment for the workers. This is managed via Julia environments.  If you use the <code>customenv=true</code> keyword argument, then when you create a cluster, the worker nodes will, at boot time, instantiate the environment. For example:</p><pre><code class="language-julia">using Pkg
Pkg.instantiate(&quot;.&quot;)
Pkg.add(&quot;AzManagers&quot;)
Pkg.add(&quot;Jets&quot;)
addprocs(&quot;cbox16&quot;,2;customenv=true)</code></pre><p>Now, when worker VMs are initialized, they will have the software stack defined by the current project.  Please note that this can add significant overhead to the boot-time of the VMs.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 4 January 2023 14:08">Wednesday 4 January 2023</span>. Using Julia version 1.8.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
